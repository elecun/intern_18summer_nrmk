// License: Apache 2.0. See LICENSE file in root directory.
// Copyright(c) 2017 Intel Corporation. All Rights Reserved.

#include <librealsense2/rs.hpp> // Include RealSense Cross Platform API
#include <opencv2/opencv.hpp>   // Include OpenCV API
#include "C:\opencv\librealsense-master\librealsense-master\examples\C\example.h"


#define	HEIGHT_METER	0.51
#define STREAM          RS2_STREAM_DEPTH  // rs2_stream is a types of data provided by RealSense device           //
#define FORMAT          RS2_FORMAT_Z16    // rs2_format is identifies how binary data is encoded within a frame   //
#define WIDTH           640               // Defines the number of columns for each frame                         //
#define HEIGHT          480               // Defines the number of lines for each frame                           //
#define FPS             30                // Defines the rate of frames per second                                //
#define STREAM_INDEX    0                 // Defines the stream index, used for multiple streams of the same type //

using namespace cv;


float get_depth_unit_value(const rs2_device* const dev)
{
	rs2_error* e = 0;
	rs2_sensor_list* sensor_list = rs2_query_sensors(dev, &e);
	check_error(e);

	int num_of_sensors = rs2_get_sensors_count(sensor_list, &e);
	check_error(e);

	float depth_scale = 0;
	int is_depth_sensor_found = 0;
	int i;
	for (i = 0; i < num_of_sensors; ++i)
	{
		rs2_sensor* sensor = rs2_create_sensor(sensor_list, i, &e);
		check_error(e);

		// Check if the given sensor can be extended to depth sensor interface
		is_depth_sensor_found = rs2_is_sensor_extendable_to(sensor, RS2_EXTENSION_DEPTH_SENSOR, &e);
		check_error(e);

		if (1 == is_depth_sensor_found)
		{
			depth_scale = rs2_get_option((const rs2_options*)sensor, RS2_OPTION_DEPTH_UNITS, &e);
			check_error(e);
			rs2_delete_sensor(sensor);
			break;
		}
		rs2_delete_sensor(sensor);
	}
	rs2_delete_sensor_list(sensor_list);

	if (0 == is_depth_sensor_found)
	{
		printf("Depth sensor not found!\n");
		exit(EXIT_FAILURE);
	}

	return depth_scale;
}

int main(int argc, char * argv[]) try
{
	rs2_error* e = 0;

	// Create a context object. This object owns the handles to all connected realsense devices.
	// The returned object should be released with rs2_delete_context(...)
	rs2_context* ctx = rs2_create_context(RS2_API_VERSION, &e);
	check_error(e);

	/* Get a list of all the connected devices. */
	// The returned object should be released with rs2_delete_device_list(...)
	rs2_device_list* device_list = rs2_query_devices(ctx, &e);
	check_error(e);

	int dev_count = rs2_get_device_count(device_list, &e);
	check_error(e);
	printf("There are %d connected RealSense devices.\n", dev_count);
	if (0 == dev_count)
		return EXIT_FAILURE;

	// Get the first connected device
	// The returned object should be released with rs2_delete_device(...)
	rs2_device* dev = rs2_create_device(device_list, 0, &e);
	check_error(e);

	print_device_info(dev);

	/* Determine depth value corresponding to one meter */
	uint16_t one_meter = (uint16_t)(1.0f / get_depth_unit_value(dev));

	// Create a pipeline to configure, start and stop camera streaming
	// The returned object should be released with rs2_delete_pipeline(...)
	rs2_pipeline* pipeline = rs2_create_pipeline(ctx, &e);
	check_error(e);

	// Create a config instance, used to specify hardware configuration
	// The retunred object should be released with rs2_delete_config(...)
	rs2_config* config = rs2_create_config(&e);
	check_error(e);

	// Request a specific configuration
	rs2_config_enable_stream(config, STREAM, STREAM_INDEX, WIDTH, HEIGHT, FORMAT, FPS, &e);
	check_error(e);

	// Start the pipeline streaming
	rs2_pipeline_profile* pipe = rs2_pipeline_start_with_config(pipeline, config, &e);
	if (e)
	{
		printf("The connected device doesn't support depth streaming!\n");
		exit(EXIT_FAILURE);
	}

/*
    // Declare depth colorizer for pretty visualization of depth data
    rs2::colorizer color_map;

    // Declare RealSense pipeline, encapsulating the actual device and sensors
    rs2::pipeline pipe;
    // Start streaming with default recommended configuration
    pipe.start();
*/
	//uint16_t one_meter = (uint16_t)(1.0f / get_depth_unit_value(dev));

    const auto window_name = "Display Image";
    namedWindow(window_name, WINDOW_AUTOSIZE);

    while (waitKey(1) < 0 && cvGetWindowHandle(window_name))
    {
        //rs2::frameset* data = pipe.wait_for_frames(); // Wait for next set of frames from the camera
		rs2_frame* frames = rs2_pipeline_wait_for_frames(pipeline, 5000, &e);
		int num_of_frames = rs2_embedded_frames_count(frames, &e);
		check_error(e);

		int i;
		for (i = 0; i < num_of_frames; ++i)
		{
			// The retunred object should be released with rs2_release_frame(...)
			rs2_frame* frame = rs2_extract_frame(frames, i, &e);
			check_error(e);

			// Check if the given frame can be extended to depth frame interface
			// Accept only depth frames and skip other frames
			if (0 == rs2_is_frame_extendable_to(frame, RS2_EXTENSION_DEPTH_FRAME, &e))
			{
				rs2_release_frame(frame);
				continue;
			}

			/* Retrieve depth data, configured as 16-bit depth values */
			const uint16_t* depth_frame_data = (const uint16_t*)(rs2_get_frame_data(frame, &e));
			check_error(e);

/*

			int x, y, depth;
			for (y = 0; y < 480; y++)
			{
				for (x = 0; x < 640; x++)
				{
					depth = *depth_frame_data;
					if (depth < 0 || depth > HEIGHT_METER*one_meter)
						depth_frame_data = 0;
					*depth_frame_data++;
				}
			}
*/

			Mat image(Size(HEIGHT, WIDTH), CV_8UC3, (void*)depth_frame_data, Mat::AUTO_STEP);
			//Mat image(Size(HEIGHT, WIDTH), CV_8UC3, (void*)(depth_frame_data - sizeof(depth_frame_data)*HEIGHT*WIDTH), Mat::AUTO_STEP);
			//Mat gimage;

			//grayscale image to binary
			//cvtColor(image, gimage, COLOR_BGR2GRAY);
			//check_error(e);
			imshow(window_name, image);
			rs2_release_frame(frame);
		}    
		rs2_release_frame(frames);
    }
	// Stop the pipeline streaming
	rs2_pipeline_stop(pipeline, &e);
	check_error(e);

	// Release resources
	rs2_delete_pipeline_profile(pipe);
	rs2_delete_config(config);
	rs2_delete_pipeline(pipeline);
	rs2_delete_device(dev);
	rs2_delete_device_list(device_list);
	rs2_delete_context(ctx);
    return EXIT_SUCCESS;
}
catch (const rs2::error & e)
{
    std::cerr << "RealSense error calling " << e.get_failed_function() << "(" << e.get_failed_args() << "):\n    " << e.what() << std::endl;
    return EXIT_FAILURE;
}
catch (const std::exception& e)
{
    std::cerr << e.what() << std::endl;
    return EXIT_FAILURE;
}



